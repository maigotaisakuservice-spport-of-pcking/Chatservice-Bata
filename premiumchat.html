<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ChatGo プレミアムチャット</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; }
    #page-content { display: flex; height: 100vh; width: 100%; }
    #chat-area { flex: 1; display: flex; flex-direction: column; border-right: 1px solid #ccc; }
    #messages { flex: 1; overflow-y: auto; padding: 10px; background: #f9f9f9; }
    #send-form { display: flex; padding: 10px; }
    #call-area { width: 400px; padding: 10px; display: flex; flex-direction: column; }
    #videos { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    video { width: 100%; background: black; border-radius: 5px; }
  </style>
</head>
<body>
  <div id="intro-video-placeholder" style="display: none;"></div>
  <div id="page-content" style="display: none;">
    <div id="chat-area">
      <h2>プレミアムグループチャット</h2>
      <div id="messages"></div>
      <div id="emoji-picker" style="display: none; border: 1px solid #ccc; padding: 10px; background: white; border-radius: 8px; position: absolute; bottom: 60px; right: 20px;">
        <!-- Emojis will be populated here -->
      </div>
      <form id="send-form" style="position: relative;">
        <button type="button" id="emoji-button" style="background: none; border: none; font-size: 24px; cursor: pointer; padding: 0 10px;">😀</button>
        <input id="message-input" style="flex:1" autocomplete="off"/>
        <button type="submit">送信</button>
      </form>
    </div>
    <div id="call-area">
      <h2>グループ通話</h2>
      <div id="videos"><video id="localVideo" autoplay muted playsinline></video></div>
      <div id="call-controls">
        <button id="start-call-btn">📞 通話開始</button>
        <button id="leave-call-btn">❌ 退出</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
    import { getFirestore, collection, doc, addDoc, onSnapshot, getDoc, setDoc, deleteDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
    import { playIntroVideo } from './intro_video.js';

    // --- Emojis ---
    const EMOJIS = {
        '::smile::': '/emoji/smile.png',
        '::laugh::': '/emoji/laugh.png',
        '::sad::': '/emoji/sad.png',
        '::angry::': '/emoji/angry.png',
        '::thumbup::': '/emoji/thumbup.png',
        '::heart::': '/emoji/heart.png',
    };

    function initApp() {
        const firebaseConfig = {
            apiKey: "AIzaSyA7CWUhLBKG_Oabxxw_7RfBpSANUoDh42s",
            authDomain: "moodmirror-login.firebaseapp.com",
            projectId: "moodmirror-login",
            storageBucket: "moodmirror-login.firebasestorage.app",
            messagingSenderId: "1091670187554",
            appId: "1:1091670187554:web:ce919c1fca5b660995b47b",
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser, localStream;
        const currentChatId = "main_premium_group";
        const peers = {};
        const iceConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

        const messagesDiv = document.getElementById('messages');
        const sendForm = document.getElementById('send-form');
        const messageInput = document.getElementById('message-input');
        const startCallBtn = document.getElementById('start-call-btn');
        const leaveCallBtn = document.getElementById('leave-call-btn');
        const emojiButton = document.getElementById('emoji-button');
        const emojiPicker = document.getElementById('emoji-picker');

        onAuthStateChanged(auth, async (user) => {
            if (!user) { window.location.href = "index.html"; return; }
            currentUser = user;
            const userDoc = await getDoc(doc(db, "users", user.uid));
            if (!userDoc.exists() || !userDoc.data().premium) {
                alert("このページはプレミアム会員限定です。");
                window.location.href = "chat.html";
                return;
            }

            // If premium, initialize UI features
            populateEmojiPicker();
            emojiButton.addEventListener('click', () => {
                emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
            });

            listenMessages(db, currentChatId, messagesDiv, currentUser.uid);
            sendForm.addEventListener("submit", (e) => sendMessage(e, db, currentUser, currentChatId, messageInput));
            startCallBtn.addEventListener("click", () => startCall(db, currentUser, currentChatId, localStream, peers, iceConfig));
            leaveCallBtn.addEventListener("click", () => leaveCall(db, currentUser, currentChatId, localStream, peers));
        });
    }

    function populateEmojiPicker() {
        const picker = document.getElementById('emoji-picker');
        picker.innerHTML = '';
        for (const code in EMOJIS) {
            const img = document.createElement('img');
            img.src = EMOJIS[code];
            img.alt = code;
            img.style.width = '30px';
            img.style.cursor = 'pointer';
            img.style.margin = '5px';
            img.addEventListener('click', () => {
                document.getElementById('message-input').value += ` ${code} `;
            });
            picker.appendChild(img);
        }
    }

    function listenMessages(db, chatId, messagesDiv, currentUserId) {
        const q = query(collection(db, "premium_chats", chatId, "messages"), orderBy("timestamp"));
        onSnapshot(q, (snapshot) => {
            messagesDiv.innerHTML = '';
            snapshot.forEach(doc => {
                const msg = doc.data();
                const div = document.createElement('div');

                let content = msg.text;
                // Replace emoji codes with images
                Object.keys(EMOJIS).forEach(code => {
                    const imgTag = `<img src="${EMOJIS[code]}" alt="${code}" style="width: 20px; height: 20px; vertical-align: middle;">`;
                    content = content.split(code).join(imgTag);
                });

                div.innerHTML = `${msg.senderName || '名無し'}: ${content}`;
                messagesDiv.appendChild(div);
            });
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
    }

    async function sendMessage(e, db, user, chatId, input) {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;
        await addDoc(collection(db, "premium_chats", chatId, "messages"), {
            sender: user.uid,
            senderName: user.displayName || user.email,
            text: text,
            timestamp: new Date()
        });
        input.value = "";
        document.getElementById('emoji-picker').style.display = 'none';
    }

    async function startCall(db, user, chatId, stream, peers, config) {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById("localVideo").srcObject = stream;
        const roomRef = collection(db, "premium_calls", chatId, "participants");

        onSnapshot(roomRef, snapshot => {
            snapshot.docChanges().forEach(async change => {
                const data = change.doc.data();
                const from = change.doc.id;
                if (from === user.uid) return;
                if (data.offer) {
                    const pc = createPeer(db, user, chatId, from, stream, peers, config);
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await setDoc(doc(roomRef, user.uid), { answer }, { merge: true });
                }
                if (data.answer && peers[from]) {
                    peers[from].setRemoteDescription(new RTCSessionDescription(data.answer));
                }
                if (data.candidate && peers[from]) {
                    peers[from].addIceCandidate(new RTCIceCandidate(data.candidate));
                }
                if (change.type === "removed") {
                    if (peers[from]) peers[from].close();
                    const video = document.getElementById(`v_${from}`);
                    if (video) video.remove();
                }
            });
        });

        const pc = createPeer(db, user, chatId, user.uid, stream, peers, config); // Self-peer for offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await setDoc(doc(roomRef, user.uid), { offer });
    }

    function createPeer(db, user, chatId, peerId, stream, peers, config) {
        const pc = new RTCPeerConnection(config);
        peers[peerId] = pc;
        stream.getTracks().forEach(track => pc.addTrack(track, stream));
        pc.onicecandidate = e => {
            if (e.candidate) {
                setDoc(doc(collection(db, "premium_calls", chatId, "participants"), user.uid), { candidate: e.candidate.toJSON() }, { merge: true });
            }
        };
        pc.ontrack = e => {
            let remoteVideo = document.getElementById(`v_${peerId}`);
            if (!remoteVideo) {
                remoteVideo = document.createElement("video");
                remoteVideo.id = `v_${peerId}`;
                remoteVideo.autoplay = true;
                remoteVideo.playsInline = true;
                document.getElementById("videos").appendChild(remoteVideo);
            }
            remoteVideo.srcObject = e.streams[0];
        };
        return pc;
    }

    async function leaveCall(db, user, chatId, stream, peers) {
        await deleteDoc(doc(db, "premium_calls", chatId, "participants", user.uid));
        Object.values(peers).forEach(pc => pc.close());
        document.querySelectorAll('video[id^="v_"]').forEach(v => v.remove());
        if (stream) stream.getTracks().forEach(track => track.stop());
    }

    // --- Init Logic ---
    const pageContent = document.getElementById('page-content');
    const introPlaceholder = document.getElementById('intro-video-placeholder');
    const INTRO_FLAG = 'hasSeenPremiumChatIntro';
    if (!localStorage.getItem(INTRO_FLAG)) {
        pageContent.style.display = 'none';
        playIntroVideo(introPlaceholder, () => {
            localStorage.setItem(INTRO_FLAG, 'true');
            pageContent.style.display = 'flex';
            introPlaceholder.innerHTML = '';
            initApp();
        });
    } else {
        pageContent.style.display = 'flex';
        initApp();
    }
  </script>
</body>
</html>
